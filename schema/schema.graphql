type Mandate {
    id: String! @id @search(by: [exact])
    name: String @search(by: [term, trigram])
    url: String
    topics: [Sdg] @hasInverse(field: mandate)
    matches: [SdgMatch] @hasInverse(field: mandate) 
}

type Sdg {
    id: String! @id @search(by: [exact])
    objects: [InfoObject] @hasInverse(field: sdgs)
    mandate: Mandate 
}

type Department {
    id: String! @id @search(by: [exact])
    objects: [InfoObject] @hasInverse(field: departments) 
    persons: [Person] @hasInverse(field: department)
}

type InfoObject @withSubscription {
    title: String @search(by: [fulltext, trigram])
    authors: [ Author ]
    year: Int @search 
    abstract: String @search(by: [fulltext, trigram])
    language: String @search(by: [exact])
    link: String! @id @search(by: [exact])
    extras: String @search(by: [fulltext, trigram])
    sdgs: [ Sdg ] @hasInverse(field: objects) 
    keywords: [ Keyword ]
    class: [ PublicationClass ]
    category: InfoObjectType @hasInverse(field: objects)
    subtype: InfoObjectSubType @hasInverse(field: objects)
    departments: [Department] @hasInverse(field: objects)
    dateUpdate: DateTime @search
    sdg_check: Int @search
    authororder: [ AuthorOrdering ]
    sdg_matches: [ SdgMatch ]
    start_date: DateTime @search
    end_date: DateTime @search
}

type Person @withSubscription {
    LDAPDN: String! @id @search(by: [exact])
    fullname: String @search(by: [term, trigram]) # always empty?
    initials: String @search(by: [exact])
    surname: String  @search(by: [term, trigram])
    givenname: String @search(by: [term, trigram])
    displayname: String @search(by: [term, trigram])
    gender: String
    title: String
    mail: String
    ipphone: String
    physicaldeliveryofficename: String
    team: Team
    directreports: [ Person ] @hasInverse(field: manager)
    manager: Person @hasInverse(field: directreports)
    department: Department
    pseudonyms: [ Author ]
    retired: Int @search
    ad_check: Int @search 
}

type Team {
    LDAPDN: String! @id @search(by: [term]) 
    person: [Person] @hasInverse(field: team)
    ad_check: Int @search
}

type Author @withSubscription {
    fullname: String! @id @search(by: [term]) 
    person: Person @hasInverse(field: pseudonyms)
    objects: [ InfoObject ] @hasInverse(field: authors)

    ad_check: Int @search
}

# Per Object Significant Author Order. 
type AuthorOrdering {
    author: Author 
    position: Int
    label: String
}

# Matching terms for the indexing process
type SdgMatch @withSubscription {
    # The construct attribute is unique per tripplet and is used to map the triplet to the CSV-filestructure
    # The construct-string is organised as follows: "sdg_" + sdg_number + "_" + construct_number + "_" + lang
    # The construct-id for  the CSV file is generated by dropping  "_" + lang from the ID string. 
    # On import the "_"+ lang is added to the construct-id provided by the CSV file. 
    construct: String! @id @search(by: [exact, trigram])
    keyword: String @search(by: [exact, trigram, fulltext, term])
    required_context: String @search(by: [exact])
    forbidden_context: String @search(by: [exact])
    language: String @search(by: [exact])
    sdg: Sdg 
    objects: [ InfoObject ] @hasInverse(field: sdg_matches)
    dateUpdate: DateTime @search
    mandate: Mandate
}

type InfoObjectType { 
    name: String! @id @search(by: [term])
    objects: [ InfoObject ] @hasInverse(field: category)
}

type InfoObjectSubType { 
    name: String! @id @search(by: [term])
    objects: [ InfoObject ] @hasInverse(field: subtype)
}

type PublicationClass { 
    id: String! @id @search
    name: String @search(by: [term])
    objects: [ InfoObject ] @hasInverse(field: class)
}

type Keyword {
    name: String! @id @search(by: [term])
    objects: [ InfoObject ] @hasInverse(field: keywords)
}
